name,所属章节,知识点描述,重要程度
翻译程序的三种方式,1,编译、解释、汇编,1
编译,1,将高级语言编写的源程序翻译成等价的机器语言或汇编语言。,2
解释,1,将高级语言编写的源程序翻译一句执行一句，不生成目标文件，直接执行源代码文件。,2
汇编,1,用汇编语言编写的源程序翻译成与之等价的机器语言。,2
编译程序的五个阶段,1,词法分析、语法分析、语义分析与中间代码生成、代码优化、目标代码生成,1
词法分析,1,对源程序的字符串进行扫描和分解，识别出每个单词符号。,2
语法分析,1,根据语言的语法规则，把单词符号分解成各类语法单位。,2
语义分析与中间代码生成,1,对各种语法范畴进行静态语义检查，若正确则进行中间代码翻译。,2
代码优化,1,遵循程序的等价变换规则。,2
目标代码生成,1,将中间代码变换成特定机器上的低级语言代码。,2
符号串和语言,2,字母表、符号串、语言,1
字母表,2,定义：字母表是有穷非空的符号集合。表示：通常用字母表大写字母A，B，…Z和希腊字母Σ表示。,2
符号串,2,定义：由字母表中的符号组成的有穷序列。表示：通常由t，u，v，w，x，y，z等小写英文字母来表示。,2
语言,2,定义：由字母表上的一些符号串组成的集合。说明：空集?是一个语言，仅含一个空符号串的集合{ε}也是一个语言。?和{ε}是不同的语言。,2
符号串集合之间的运算,2,并集、乘积、幂运算、正闭包与闭包,1
并集,2,设A和B是符号串的集合，则A和B的并集定义为A∪B = {x | x∈A or x∈B}。,2
乘积,2,设A和B是符号串的集合，则A和B的乘积定义为AB = {xy | x∈A and y∈B}。,2
幂运算,2,设A是符号串的集合，则A的幂运算定义为A0 = {ε}，A1 = A，An = AAn-1（n>0）,2
正闭包与闭包,2,设A是符号串的集合，则集合A的正闭包A+和闭包A*定义为A+ = A1∪A2∪…∪An∪…， A* = A0∪A1∪…∪An∪…,2
产生式规则,2,定义：一个产生式规则是一个有序对(A，α)。通常写作A→α或A::=α。 ”→"或”::=”表示“定义为”、“由…组成”、“生成”。含义： A→α表示左部符号A生成右部符号串α。,2
文法,2,定义：产生式规则的非空有穷集合。由四元组G=(VN，VT，P，Z)组成。,2
直接推导,2,"令G=(VN，VT，P，Z)，若A→γ∈P，且α,β∈(VN∪VT)*，则称αAβ直接推导出αγβ，表示成αA ? βαγβ。",2
推导,2,若存在一个直接推导序列：α0?α1?α2?…?αn，则称这个序列是一个从α0至αn的长度为n的推导。,3
句型和句子,2,句型：若Z ?* x，x∈(VN∪VT)*，则称符号串x为文法G[Z]的句型。句子：若Z ?* x，x∈VT*，则称符号串x为文法G[Z]的句子。句子一定是句型，句型不一定是句子。,3
递归规则,2,定义：一个产生式规则中，出现在左部的非终结符也出现在其右部。种类：左递归、右递归、递归。,3
文法递归,2,定义：对于文法中的任一非终结符，若能建立一个推导过程，在推导所得的符号串中又出现该终结符本身，则称文法是递归的。种类：左递归、右递归、递归。,3
短语,2,若存在Z ?+ αAδ且A ?+ β，则称β是句型αβδ相对于非终结符A的短语。,3
直接短语,2,若存在Z ?+ αAδ且A?β，则称β是句型αβδ相对于产生式规则A→β的直接短语。,3
句柄,2,一个句型的最左直接短语称为该句型的句柄。,3
最左推导,2,对一个推导序列中的每一步直接推导α?β，都是对α中的最左非终结符进行替换。,3
最右推导(规范推导),2,对一个推导序列中的每一步直接推导α?β，都是对α中的最右非终结符进行替换。,3
规范句型,2,由规范推导得到的句型。,3
最左归约(规范归约),2,规范推导的逆过程。,3
语法分析树,2,一个句型推导过程的树形表示称为语法分析树，简称语法树。,3
文法的二义性,2,定义：若一个文法存在某个句子对应两棵不同的语法树，则称这个文法是二义的。特点：为编译程序的执行带来不确定性。,3
二义性的消除,2,1、不改变文法：通过附加限制性条件消除二义性。寻找充分不必要条件，当文法满足这些条件时可确保文法是无二义性的。2.改变文法：改写原有文法，把排除二义性的规则合并到原文法消除二义性。,3
文法的化简,2,1.若一个非终结符不能推导出终结字符串，则该非终结符是无用的，删除所有包括该非终结符的产生式规则。2.若一个符号不能出现在文法的任何句型中，则该符号是无用的，删除所有包括该符号的产生式规则。,3
语言的分类,2,0型文法(短语文法)、1型文法(上下文敏感文法)、2型文法(上下文无关文法)、3型语言(正规文法),1
0型文法(短语文法),2,特点：0型文法的能力相当于图灵机，识别能力最强。,2
1型文法(上下文敏感文法),2,"定义：若文法G[Z]=(VN，VT，P，Z)中的每个产生式规则的形式为：αAβ→αvβ，其中α,β∈(VN∪VT)*，A∈VN，v∈(VN∪VT)+，则G[Z]为1型文法。",2
2型文法(上下文无关文法),2,特点：语法结构上下文无关，一般用于识别程序设计语言的语法结构。,2
3型语言(正规文法),2,种类：右线性文法、左线性文法；特点：作为定义程序设计语言规则的文法,2
词法分析器的任务,3,功能：输入源程序，输出单词符号。,3
单词的种类,3,关键字、标识符、常数、运算符、界限符,3
确定的有限自动机,3,定义：一个确定的有限自动机(DFA) M是一个五元组：M=(S，Σ，δ，s0，F),1
DFA的状态转移矩阵,3,DFA可用一个二维矩阵表示，矩阵的行表示状态，列表示输入字符，矩阵元素表示δ(s，a)的值。,2
DFA的状态转换图,3, 若设DFA M含有m个状态和n个输入字符，则这个图含有m个状态结点，每个结点至多有n条箭弧射出与其它的状态结点相连接，每个箭弧用Σ中的一个不同输入字符作为标记。整张图含有唯一的初态结点和若干终态结点。,2
DFA识别字符串,3,对Σ上的任何符号串w∈Σ*，若存在一条从初态结点到某一终态结点的通路，且该通路上所有弧的标记符连接成的字符串等于w，则称w可被DFA M所识别。若M的初态结点同时又是终态结点，则空字符串ε被M所识别。,2
δ的递归扩展定义,3, 对一个DFA M，其识别的语言L(M)={w|w∈Σ*，若存在Z∈F，使δ(s0，w)=Z}，其中：w=ua∈Σ*，则δ(s，ε)=s，δ(s，ua)= δ(δ(s，u)，a)。,2
不确定有限自动机,3,定义：一个不确定有限自动机(NFA) M是一个五元组：M=(S，Σ，δ，S0，F),1
NFA的状态转换图,3,若设NFA M含有n个状态和m个输入符号，则这个图含有n个状态结点，每个结点可射出若干箭弧与其它的状态结点相连接。对于w∈{ε}∪Σ，若δ(q0，a)={q1，q2，…，qk}(k≥0)，则从q0出发，分别到q1，q2，…，qk的k条弧，弧上均标记为a。整张图含有唯一的初态结点和若干终态结点。,2
NFA识别字符串,3,对Σ*上的任何符号串，若存在一条从某一初态结点到某一终态结点的通路，且该通路上所有弧的标记符号依次连接成的字符串等于w，则称w可被NFA M所识别。若M的某些结点同时又是终态结点，则空字符串ε被M所识别。,2
DFA和NFA的关系,3,1）DFA是NFA的特例，NFA是DFA概念的推广。 2）NFA能识别的语言都能被一个DFA识别。3）DFA相对NFA的识别程序更容易实现。,2
NFA的确定化,3,对任给的NFA M。都能相应地构造一个DFA M‘，使得L(M’)=L(M)。,3
NFA的化简思路,3,DFA的每一个状态代表NFA状态集合的某个子集，构造的DFA使用它的状态去记录NFA读入输入符号之后可能到达的所有状态的集合。,3
正规式与正规集,3,NULL,1
正规式的运算,3,1）种类：或”|”、连接”.”、闭包”*”。 2）优先级：闭包>连接>或 ；3）说明：仅由有限次使用这三种运算而得到的表达式才是Σ上的正规式。仅由这些正规式表示的单词集才是Σ上的正规式。,2
正规式的等价,3,若两个正规式U和V描述的正规集相同，则称正规式U和V等价。,2
正规文法转换为正规式,3, 1）将正规文法中的每个非终结符表示成它的一个正规式方程，获得一个联立方程组。 2）若x=αx|β(或x=αx+β)，则解为x=α*β。3）若x=xα|β(或x=xα+β)，则解为x=βα*。,3
语法分析器,4,功能：以词法分析器生成的单词符号序列作为输入，在分析过程中验证这个单词符号序列是否是该程序设计语言的文法的一个句子。,1
语法分析方法的种类,4,自顶向下和自底向上。,2
自顶向下的语法分析,4,定义：从顶部(树根)建立语法分析树，构造一个最左推导，面对当前输入的单词符号和当前被替换的非终结符，选择这个非终结符的某个产生式规则进行替换。,2
LL(1)文法,4,"定义:1）文法不含左递归。 2）对某个非终结符A，若其对应的产生式规则为A→α1|α2|…αn，则First(αi)∩First(αj)=?(1≤i,j≤n且i≠j)。  3）对文法中的每个非终结符A，若A ?* ε，则First(αi)∩Follow(A)=?(1≤i≤n)。",1
First集,4,设G[Z]=(VN，VT，P，Z)，α∈(VN∪VT)*，符号串α的首符号集合的定义为： First(α)={a|α ?* a…且a∈VT}  若α ?* ε，则规定ε∈First(α)。,2
Follow集,4,设G[Z]=(VN，VT，P，Z)，A∈VN，非终结符号A的后继符号集合的定义为： Follow(A)={a|Z ?* …Aa…且a∈VT}  若Z ?* …A，则规定#∈First(A)。#为结束符。,2
回溯的判断,4,"对一个上下文无关文法G[Z]=(VN，VT，P，Z)，对某个产生式规则A→α1|α2|…αn，若存在a∈VT，使得a∈First(αi)∩First(αj)(1≤i,j≤n且i≠j)或a∈First(αi)∩Follow(A)(1≤i≤n，A ?* ε)或αi ?* ε且αj ?* ε(1≤i,j≤n且i≠j)，则对应于文法G的自顶向下分析需要回溯。",2
回溯的消除,4, 1）提取左因子。若有A→αβ1|αβ2|…|αβ1|γ，其中γ不是以α开头的候选式，则A的产生式规则可替换为A→αA‘|γ，A’→β1|β2|…|βn。A’是一个新的非终结符号。 2）消除左递归。,2
递归下降分析器。,4,定义：由一组递归函数或过程组成，每个函数或过程对应文法的一个非终结符的程序，称为递归下降分析器。,3
预测分析的出错处理,4,1.出错情况  2.解决思路 3.同步符号集的选择,1
出错情况,4," 1）栈顶上的终结符号与下一个输入符号不匹配。 2）栈顶上是非终结符号A，下一个输入符号是a，但分析表M[A,a]为空。",2
解决思路,4,跳过输入串中的一些符号，直到遇到“同步符号“为止。,2
同步符号集的选择,4, 1）把Follow(A)中的所有符号放入非终结符A的同步符号集。若跳读一些符号直到出现Follow(A)中的符号，把A从栈中弹出，这样就可能使分析继续下去。 2）对于非终结符A，只用Follow(A)作为它的同步符号集是不够的。,2
自底向上的语法分析,5,1.工作方式：移进-归约。2.基本思想：将输入符号串中的符号从左向右逐个的移进栈，每当栈顶形成某一个可归约子串时，就把该可归约子串归约成某一个非终结符号。即先把该可归约子串从栈顶逐出，再把归约的非终结符号压进栈。,3
算符优先关系,5,1.算符文法  2.算符相邻  3.算符优先级 4.算符优先文法,1
算符文法,5,若文法G中不存在规则：A→UV…，其中A，U，V均为非终结符，则称该文法是算符文法。通常，算符文法也不包含A→ε。,2
算符相邻,5,"若有ab或aWb，其中a,b∈VT，W∈VN，则称运算符a与b相邻。",2
算符优先级,5,"设文法G是一个算符文法，对文法G中任何一对终结符a和b，定义： 1）a =· b：当且仅当文法G中存在规则A→…ab…或A→…aRb…，其中a,b∈VT，R∈VN。2）a ＜· b：当且仅当文法G中存在规则A→…aR…且R ?+ b…或R ?+ Qb…，其中a,b∈VT，Q,R∈VN。  3）a ·＞ b：当且仅当文法G中存在规则A→…Rb…且R ?+ …a或R ?+ …aQ，其中a,b∈VT，Q,R∈VN。",2
算符优先文法,5,若一个算符文法G中任何一对终结符号a与b之间最多存在=·、＜·、·＞中的一种，则称文法G是一个算符优先文法。,2
优先函数,5,1.目的：减小优先关系表的大小。2.基本思想：每一个运算符配上两个数。当终结符在左边出现时，配的数是f(a)；当a在右边出现时，配的数是g(a)，若每一个终结符都能如愿配上两个数，则优先关系表的大小就从n×n减小到2n。,1
优先函数的优点,5,优点：存储空间从n×n减小到2n。,2
优先函数的缺点,5,缺点：原本在优先关系表中不存在优先关系的终结符对产生了优先级关系，使原本能立即发现的错误向后推迟一段时间才被发现。,2
LR分析技术,5,1）L代表从左向右分析，R代表最右推导，k代表向前查看k个字符。  2）LR分析法实际上是最右推导的逆过程——最右归约。 3）LR(k)分析技术利用已经移进栈中的和归约后进入栈中的一切文法符号，并向前查看最多k个符号，从而确定句柄是否已经在栈顶形成，一旦句柄出现在栈顶，立即进行归约。,1
LR(k)技术的分类,5,LR(0)分析法、SLR(1)分析法、LR(1)分析法、LALR(1)分析法。,2
LR分析器组成,5,一个输入串、一个分析栈、一张LR分析表、LR分析器总控程序。,2
SLR(1)分析技术,5,含义：简化了的LR(1)分析技术。,3
LALR(1)分析技术,5, 1）LALR(1)分析表的结构和大小与SLR(1)相同，比LR(1)的分析表小。2）LALR(1)的分析能力比SLR(1)强，比LR(1)稍弱。,3
属性文法,6,对文法中的每一个符号(终结符或非终结符)指派若干表达语义的值，这些值称为属性。在上下文无关文法中配置上语义规则，这样的文法称为属性文法。,3
继承属性,6,使用场景：一个结点的继承属性值由其父结点的属性值或兄弟结点的属性值来确定。用于表达上下文的依赖性。,3
综合属性,6,使用场景：一个结点的综合属性值由其子结点的属性值确定,3
S-属性定义,6,若属性文法中所有的属性均为综合属性，则称为S-属性定义(S-属性文法)。,3
L-属性定义,6,若文法G的每一条产生式规则A→X1X2…Xn所配置的语义规则中的每一个属性或者都是综合属性，或者是Xk的一个继承属性，且该继承属性仅依赖于A的继承属性及Xk左部的X1，X2，…，Xk-1的任何属性，则称该属性文法为L-属性定义(L-属性文法)。,3
栈中的继承属性,6,1.复写规则：设Y.y是继承属性，X.s是综合属性，且有Y.y=X.s，则称Y.y=X.s为复写规则。2.基本思想：在引用继承属性时，引用其指向的综合属性。,3
语义分析,7,主要任务：分析源程序的含义并做出相应的语义处理,3
图表示,7,形式：将表达式的运算符作为一个结点，操作数作为这个结点的子结点。当重复引用一个子表达式时，可直接重复使用这个子表达式所对应的结点。这样树形结构变成了有向无环图，简称DAG。,3
抽象语法树,7,形式：将运算符、关键字作为树的内部结点，运算对象作为树的叶子结点，这样构成了一棵抽象语法树。,3
三地址代码,7,1.形式：三地址代码的形式为x:=y op z。其中，y、z可以是名字、常数、临时变量等。X可以是名字或临时变量。op代表运算符。2.特点：式子右部只能有一个运算符。,3
四元式,7,形式：四元式的形式是(op，arg1，arg2，result)。其中，op是运算符，arg1和arg2是操作对象，result存放最终结果。若op是单目运算符，则arg2可以省略。,3
三元式,7,形式：三元式的形式是( p )(op，arg1，org2)。其中op是运算符，arg1和arg2是操作对象。运算的结果由该三元式的位置( p )来引用。,3
逆波兰式,7,特点：操作数的先后次序不变，而运算符的先后次序是真正运算的先后次序。eg：将a*(b+c)翻译成逆波兰式代码：  abc+*,3
运行时环境的组成,8,运行时刻存储空间的管理策略、符号表的管理、垃圾回收策略、运行支持库等。,3
静态存储分配策略,8,1.适用：对所有的static型局部变量和所有的全局变量采用静态存储分配策略。2.原因：全局变量及static型局部变量的大小在编译时就可以知道，而且无论程序中嵌套调用多少次，其变量永远只有一份。,3
栈式存储分配策略,8,1.适用：对函数内部的非static型局部变量采用栈式存储分配策略。2.原因：函数可以直接或间接的递归调用。函数中的局部变量，可能出现多个实例。每递归调用一次，都会创建一个局部变量的实例。,3
堆式存储分配策略,8,1.适用：对于指针类变量所指的空间采用堆式存储分配策略2.原因：指针变量所指的空间的大小和位置，有时只有在程序运行时才能知道。,3
符号常量,9,有时我们需要对涉及某些变量的循环嵌套结构进行优化，这些变量对于该嵌套中的所有循环都是循环不变的。我们把这样的变量称为符号常量( symbolic constant)。,3
数据复用,9,对于局部性优化，我们希望识别出访问相同数据或相同高速缓存线的迭代集合。,3
中间代码生成,9,经过语法分析和语义分析后，许多编译器为源程序产生更低级的显示中间表示，可以理解为一种抽象的程序。,3
机器语言,9,机器语言是机器能直接识别的程序语言或指令代码，勿需经过翻译，每一操作码在计算机内部都有相应的电路来完成它，或指不经翻译即可为机器直接理解和接受的程序语言或指令代码。机器语言使用绝对地址和绝对操作码。不同的计算机都有各自的机器语言，即指令系统。从使用的角度看，机器语言是最低级的语言。,3
汇编语言,9,汇编语言（assembly language）是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。特定的汇编语言和特定的机器语言指令集是一一对应的，不同平台之间不可直接移植。,3
高级编程语言,9,高级编程语言（High-level programming language）是高度封装了的编程语言，与低级语言相对。它是以人类的日常语言为基础的一种编程语言，使用一般人易于接受的文字来表示，有较高的可读性，以方便对电脑认知较浅的人亦可以大概明白其内容。,3
