name,重要程度,所属章节,知识点描述
基本操作,3,,
二叉树的遍历,4,6,"二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有的结点，使得每个结点被访问依次且仅被访问一次。
四种遍历方式分别为：先序遍历、中序遍历、后序遍历、线索化二叉树。"
先序遍历二叉树,4,6,先序遍历(Pre-order)，按照根左右的顺序沿一定路径经过路径上所有的结点。在二叉树中，先根后左再右。巧记：根左右。
中序遍历二叉树,4,6,中序遍历(LDR)是二叉树遍历的一种，也叫做中根遍历、中序周游。在二叉树中，中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。巧记：左根右。
后序遍历二叉树,4,6,后序遍历(LRD)是二叉树遍历的一种，也叫做后根遍历、后序周游。后序遍历有递归算法和非递归算法两种。巧记：左右根。
图的遍历,4,7,图的遍历指的是从图中的任一顶点出发，对图中的所有顶点访问一次且只访问一次。
深度优先搜索,4,7,深度优先搜索，其别名又叫DFS，属于图算法的一种。利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。
广度优先搜索,4,7,广度优先搜索，其别名又叫BFS，属于一种盲目搜寻法，是连通图的一种遍历算法这一算法也是很多重要的图的算法的原型。
树的遍历,4,6,树的遍历是树的一种重要的运算。所谓遍历是指对树中所有结点的信息的访问，即依次对树中每个结点访问一次且仅访问一次。树的3种最重要的遍历方式分别称为前序遍历、中序遍历和后序遍历。
先根遍历树,4,6,先根遍历，也叫先序遍历，遍历的顺序是，根，左子树，右子树
中根遍历树,4,6,中根遍历，也叫中序遍历，顺序是左子树、根、右子树。
后根遍历树,4,6,后根遍历，也叫后序遍历，遍历顺序是左子树、右子树、根。
线索二叉树,2,6,对于n个结点的二叉树，在二叉链存储结构中有n+1个空链域，利用这些空链域存放在某种遍历次序下该结点的前驱结点和后继结点的指针，这些指针称为线索，加上线索的二叉树称为线索二叉树。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种。
先序线索二叉树,2,6,在先序线索二叉树中查找结点的后继较容易，而查找前驱要知道其双亲的信息，要使用栈，所以说先序线索二叉树是不完善的。
中序线索二叉树,2,6,若结点的ltag=1，lchild指向其前驱;否则，该结点的前驱是以该结点为根的左子树上按中序遍历的最后一个结点。若rtag=1，rchild指向其后继;否则，该结点的后继是以该结点为根的右子树上按中序遍历的第一个结点。
后序线索二叉树,2,6,在后序线索二叉树中查找结点*p的前驱:若结点*p无左子树，则p->lchild指向其前驱;否则，若结点*p有左子树，当其右子树为空时，其左子树的根(即p->lrchild)为其后序前驱。当其右子树非空时，其右子树的根(即p->rchild)为其后序前驱。
基本算法,4, ,
排序算法,4,10,所谓排序算法，即通过特定的算法因式将一组或多组数据按照既定模式进行重新排序。
内部排序,4,10,"内部排序是指待排序列完全存放在内存中所进行的排序过程，适合不太大的元素序列。内部排序方法:1.插入排序(直接插入排序);2.快速排序;3.选择排序(简单选择排序);4.归并排序 ;5.冒泡排序;6.希尔排序;希尔排序是对直接插入排序方法的改进。7.堆排序;8.基数排序;

"
交换排序,4,10,所谓交换，就是根据序列中两个记录键值的比较结果来对换这两个记录在序列中的位置，交换排序的特点是:将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。
冒泡排序,4,10,每一趟只能确定将一个数归位，如果有n个数进行排序，只需将n-1个数归位，也就是说要进行n-1趟操作，而每一趟都需要从第1位开始进行相邻两个数的比较。
快速排序,4,10,通过一趟排序将要排序的数据分割成独立的两部分，分割点左边都是比它小的数，右边都是比它大的数。然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
基数排序,4,10,"将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。"
归并排序,4,10,将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。归并排序是一种稳定的排序方法。
插入排序,4,10,插入排序的基本思想是:每步将一个待排序的纪录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。
折半插入排序,4,10,折半插入排序(Binary Insertion Sort)是对插入排序算法的一种改进。所谓插入排序，就是不断的依次将元素插入前面已排好序的序列中。时间复杂度为O(n^2)。
希尔排序,4,10,"对于n个待排序的数列，取一个小于n的整数gap(步长)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中；对各组内的元素进行直接插入排序。这一趟排序完成之后，每一个组的元素都是有序的。减小gap的值，重复执行上述的分组和排序。当gap=1时，整个数列就是有序的。最坏时间复杂度是O(n^s) , 1<s<2, s是所选的分组。"
直接插入排序,4,10,插入排序通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入，如此重复，直至完成序列排序。时间复杂度为 o(n^2)。
2-路插入排序,1,10,2-路插入排序算法是在直接插入排序算法的基础上增加了一个辅助数组，其目的是减少排序过程中的移动次数，需要增加n个记录的辅助空间。时间复杂度为O(n^2)。
选择排序,4,10,选择排序(Selection sort)是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小(或最大)的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法(比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面)。
堆排序,3,10,堆排序(Heapsort)是指利用堆积树(堆)这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。
简单选择排序,3,10,简单选择排序的思想是，从第一位置开始，逐渐向后，选择后面的无序序列中的最小值放到该位置。
外部排序,1,11,外部排序指的是大文件的排序，即待排序的记录存储在外存储器上，待排序的文件无法一次装入内存，需要在内存和外部存储器之间进行多次数据交换，以达到排序整个文件的目的。
查找算法,3,9,用关键字标识一个数据元素，查找时根据给定的某个值，在表中确定一个关键字的值等于给定值的记录或数据元素。
动态查找表,3,9,"动态查找表的特点是表结构本身在查找过程中动态生成,即对给定的关键字key，若表中存在其关键字等于key的记录，则查找成功返回，否则插入关键字等于key的记录。设计一个有关动态查找表（以二叉排序树为例）的建立、查找、插入和删除等基本操作的演示程序。"
B+树查找,3,9,B+ 树是一种树数据结构，是一个n叉排序树，每个节点通常有多个孩子，一棵B+树包含根节点、内部节点和叶子节点。B+树不仅支持顺序检索，还支持索引查找。
B-树查找,3,9,B-树的查找类似二叉排序树的查找，所不同的是B-树每个结点上是多关键码的有序表，在到达某个结点时，先在有序表中查找，若找到，则查找成功；否则，到按照对应的指针信息指向的子树中去查找，当到达叶子结点时，则说明树中没有对应的关键码。B-树不支持顺序检索，仅能支持索引查找。
二叉排序树查找,2,9,在二叉排序树中进行查找的过程和二分查找类似，也是一个逐步缩小查找范围的过程。若查找成功，则是走了一条从根结点到待查结点的路径；若查找失败，则是走了一条根结点到某个叶子结点的路径。因此，查找过程中和关键字比较的次数不超过树的深度。
哈希表查找,2,9,哈希查找也叫散列查找，整个散列查找过程大概分两步：（1）在存储时通过散列函数计算记录的散列地址，并按此散列地址存储该记录。（2）当查找时，一样通过散列函数计算记录的散列地址，然后访问散列地址的记录。
静态查找表,2,9,静态查找表(Static Search Table) ：只作查找操作的查找表，主要操作为：（1）查询某个“特定的”数据元素是否在查找表中。（2）检索某个“特定的”数据元素和各种属性。
分块查找,2,9,分块查找是折半查找和顺序查找的一种改进方法，分块查找由于只要求索引表是有序的，对块内节点没有排序要求，因此特别适合于节点动态变化的情况。
折半查找,2,9,折半查找的基本思想：减少查找序列的长度，分而治之地进行关键字的查找。他的查找过程是：先确定待查找记录的所在的范围，然后逐渐缩小查找的范围，直至找到该记录为止（也可能查找失败）。
索引排序查找,2,9,索引顺序查找，也叫分块查找，算法实现除了需要查找表本身之外，还需要根据查找表建立一个索引表。
顺序查找,2,9,顺序查找是按照序列原有顺序对数组进行遍历比较查询的基本查找算法。
存储结构,4,,数据元素之间的关系有两种不同的表示方法:顺序映象和非顺序映象，并由此得到两种不同的存储结构:顺序存储结构和链式存储结构。
图状结构,4,7,图状结构是多对多关系形成的逻辑结构。其中每个元素的直接前趋和直接后继数目都不限。
有向图,4,7,一个有向图D是指一个有序三元组(V(D)，A(D)，ψD)，其中ψD为关联函数，它使A(D)中的每一个元素(称为有向边或弧)对应于V(D)中的一个有序元素(称为顶点或点)对。
强连通图,4,7,强连通图(Strongly Connected Graph)是指在有向图G中，如果对于每一对vi、vj，vi≠vj，从vi到vj和从vj到vi都存在路径，则称G是强连通图。有向图中的极大强连通子图称做有向图的强连通分量。
无向完全图,4,7,无向完全图是用n表示图中顶点数目的一种完全图，该图中每条边都是无方向的。
有向完全图,4,7,有向完全图是指图中各边都有方向，且每两个顶点之间都有两条方向相反的边连接的图。
无向图,4,7,边没有方向的图称为无向图。
完全图,4,7,在图论的数学领域，完全图是一个简单的无向图，其中每对不同的顶点之间都恰连有一条边相连。完整的有向图又是一个有向图，其中每对不同的顶点通过一对唯一的边缘（每个方向一个）连接。
强连通分量,4,7,"有向图强连通分量：在有向图G中，如果两个顶点vi,vj间（vi>vj）有一条从vi到vj的有向路径，同时还有一条从vj到vi的有向路径，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。"
连通分量,4,7,无向图G的极大连通子图称为G的连通分量( Connected Component)。任何连通图的连通分量只有一个，即是其自身，非连通的无向图有多个连通分量。
连通图,4,7,在一个无向图 G 中，若从顶点i到顶点j有路径相连（当然从j到i也一定有路径），则称i和j是连通的。如果 G 是有向图，那么连接i和j的路径中所有的边都必须同向。如果图中任意两点都是连通的，那么图被称作连通图。如果此图是有向图，则称为强连通图（注意：需要双向都有路径）。
生成树,3,6,生成树可以定义为连通的无向图G的子图，该图是通过从图中移除所需数量的边而产生的树。换句话说，生成树是连接和无向图G的非循环子图，其将所有顶点连接在一起。图G可以具有多个生成树。连通无向图的生成树包含原图中所有的点，树的边也是原图中存在的边。
线性结构,3,2,线性结构是一个有序数据元素的集合。常用的线性结构有：线性表，栈，队列，双队列，串(一维数组)。
广义表,3,5,广义表(Lists，又称列表)是一种非线性的数据结构，是线性表的一种推广。即广义表中放松对表元素的原子限制，容许它们具有其自身结构。广义表定义：广义表是n(n≥0)个元素a1，a2，…，ai，…，an的有限序列。
数组,3,5,所谓数组，是有序的元素序列。
栈,3,3,栈（stack）是限定在表尾进行插入和删除操作的线性表（或单链表）。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。
链栈,4,3,链栈的结点定义和单链表一样，只不过它只能在栈顶操作而已。链栈的基本操作：1、初始化操作InitStack；2、判断一个链栈是否为空栈StackEmpty；3、求链栈的长度StackLength；4、入栈操作Push()；5、出栈操作Pop；6、取栈顶元素操作GetTop()。
顺序栈,2,3,顺序栈是分配一段连续的空间，需要两个指针，base指向栈底，top指向栈顶。而链栈每个结点的地址是不连续的，只需要一个栈顶指针即可。
线性表,4,2,线性表（linear list）是数据结构的一种，一个线性表是n个具有相同特性的数据元素的有限序列。
单链表,2,2,单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。链表中的数据是以结点来表示的，每个结点的构成：元素(数据元素的映象) + 指针(指示后继元素存储位置)，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。
静态链表,2,2,用数组描述的链表，即称为静态链表。
双向链表,2,2,双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。
循环链表,4,2,循环链表是另一种形式的链式存贮结构。它的特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。
队列,2,3,队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。
链队列,1,3,"队列中结点采取链接方式存贮的队列,称为链队列。"
循环队列,1,3,循环队列是把顺序队列首尾相连，把存储队列元素的表从逻辑上看成一个环，成为循环队列。
集合,2,2,list集合是线性数据结构的主要表现，集合元素通常明确的上一个和下一个元素，也存在明确的第一个元素和最后一个元素。
树形结构,3,6,树形结构是一层次的嵌套结构。 一个树形结构的外层和内层有相似的结构， 所以这种结构多可以递归的表示。经典数据结构中的各种树状图是一种典型的树形结构：一颗树可以简单的表示为根， 左子树， 右子树。 左子树和右子树又有自己的子树。
树,3,6,树(tree)是n(n>0)个节点的有限集，在任意一棵树中，(1)有且仅有一个特定的称为根(root)的节点，(2)当n>1时，其余节点可分为m(m>0)个互不相交的有限集，而每个集合本身又是一棵树，称为根的子树(subtree)。
一般树,3,6,由结点或顶点和边组成的(可能是非线性的)且不存在着任何环的一种数据结构。
B+树,3,6,B+ 树是一种树数据结构，通常用于关系型数据库（如Mysql）和操作系统的文件系统中。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入，这与二叉树恰好相反。
B-树,3,6,B树（英语：B-tree）是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一个一般化的二叉查找树（binary search tree），可以拥有最多2个子节点。
键树,1,6,如果一个关键字可以表示成字符的序号，即字符串，那么可以用键树（keyword tree），又称数字搜索树（digital search tree）或字符树，来表示这样的字符串的集合。
一般二叉树,2,6,"一棵二叉树是节点的一个有限集合,该集合或者为空,或者由一个根节点加上两棵左子树和右子树组成。"
完全二叉树,2,6,若设二叉树的深度为h，除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树。
平衡二叉树,4,6,当且仅当任何节点的两棵子树的高度差不大于1的二叉树。
满二叉树,2,6,除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。也可以这样理解，除叶子结点外的所有结点均有两个子结点。节点数达到最大值，所有叶子结点必须在同一层上
最优二叉树,1,6,给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。
赫夫曼树,4,6,哈夫曼树是一种带权路径长度最短的二叉树，也称为最优二叉树。
二叉排序树,1,6,一棵空树，或者是具有下列性质的二叉树：（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；（3）左、右子树也分别为二叉排序树；（4）没有键值相等的结点。
森林,1,6,森林(forest)是m(m≥0)棵互不相交的树的集合。任何一棵树，删除了根结点就变成了森林。